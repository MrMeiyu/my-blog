<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTML5 Web Speech API]]></title>
    <url>%2Fmy-blog%2F2019%2F07%2F22%2FHTML5-Web-Speech-API%2F</url>
    <content type="text"><![CDATA[前言 之所以写这篇文章主要就是在我司的老项目中有个需求，此需求就是根据页面重量播放语音，比如：56KG,那么页面就会读出来这个数字 Speech Synthesis API 因为之前没有过这种需求所以只能去百度下，然后就发现了 HTMl5 SpeechSynthesis API HTML5 中 Web Speech 其实有两类的：a. 是 Speech Recognition 代表的是语音识别,通俗来说就是语音转文字;b. 是 Speech Synthesis 代表的是语音合成,通俗来说就是文字转语音. 使用方式 语音识别 123456789101112// 创建实例const demo = webkitSpeechRecognition();// 开demo.start();// 关demo.stop();// 事件机制demo.onresult = function(e) &#123; console.log(e);&#125; 详细的地址参考 语音合成 123// 举个栗子const demo = new window.SpeechSynthesisUtterance('hello world');window.speechSynthesis.speak(demo); 上面这段代码可以试着放在控制台然后就可以听到声音了 SpeechSynthesisUtterance 和 speechSynthesis 为核心的API 其他方法和属性请看这里,走你 以上就是这次所学，因为太简单了，所以没有写过多的代码。还有这个API其实以后会应用的更多，比如适合“盲人”。]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
        <category>语音</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>语音</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教你如何在网页中使用RTMP看视频]]></title>
    <url>%2Fmy-blog%2F2019%2F04%2F29%2F%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%AD%E4%BD%BF%E7%94%A8RTMP%E7%9C%8B%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[任何使用RTMP在VideoJS中播放 其实 github 上开源了一个基于 vudeo.js 封装的一个 vue 的组件但是老是报错，所以这篇文章主要还是教你使用 vudeo.js 下载的依赖 ⚠️请使用 yarn 或者 npm 下载 video.js // yarn add video.js -S video.flash // yarn add video.flash -S 切换到flash，因为html5播放不了RTMP格式的流 还有一个 swf 的文件，因为我下载引入老是不对，索性我就找了一个在线的 https://vjs.zencdn.net/swf/5.3/video-js.swf 这是我的 package.json 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; "name": "koa2-fe-vue", "version": "0.1.0", "private": true, "scripts": &#123; "serve": "vue-cli-service serve", "build": "vue-cli-service build", "lint": "vue-cli-service lint" &#125;, "dependencies": &#123; "axios": "^0.18.0", "echarts": "^4.2.1", "element-ui": "^2.5.4", "js-cookie": "^2.2.0", "v-charts": "^1.19.0", "video.js": "^7.5.4", "videojs-flash": "^2.1.0", "vue": "^2.6.6", "vue-i18n": "^8.10.0", "vue-router": "^3.0.1", "vuex": "^3.0.1" &#125;, "devDependencies": &#123; "@vue/cli-plugin-babel": "^3.0.5", "@vue/cli-plugin-eslint": "^3.4.0", "@vue/cli-service": "^3.0.5", "@vue/eslint-config-prettier": "^4.0.1", "babel-eslint": "^10.0.1", "babel-plugin-component": "^1.1.1", "babel-plugin-transform-remove-console": "^6.9.4", "eslint": "^5.8.0", "eslint-plugin-vue": "^5.0.0", "file-loader": "^3.0.1", "imagemin-jpegtran": "^6.0.0", "imagemin-pngquant": "^7.0.0", "loadsh": "^0.0.4", "lodash-webpack-plugin": "^0.11.5", "node-sass": "^4.11.0", "sass": "^1.17.3", "sass-loader": "^7.1.0", "vue-cli-plugin-axios": "^0.0.4", "vue-cli-plugin-element": "^1.0.1", "vue-template-compiler": "^2.5.21" &#125;&#125; 编写代码 从官网中看了下代码的 🌰 ，所以代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 &lt;template&gt; &lt;div class="video"&gt; &lt;h2&gt;VideoJS 流媒体&lt;/h2&gt; &lt;video id="myVideo" class="video-js vjs-default-skin" controls preload="auto" crossOrigin="anonymous" width="400" &gt; &lt;!-- eslint-disable-next-line --&gt; &lt;source src="rtmp://184.72.239.149/vod/&amp;mp4:BigBuckBunny_115k.mov" type="rtmp/flv" /&gt; &lt;p class="vjs-no-js"&gt; To view this video please enable JavaScript, and consider upgrading to a web browser that &lt;a href="https://videojs.com/html5-video-support/" target="_blank"&gt; supports HTML5 video &lt;/a&gt; &lt;/p&gt; &lt;/video&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;/* VideoJS */import 'video.js/dist/video-js.css'import videojs from 'video.js'import 'videojs-flash'export default &#123; name: 'Video', data() &#123; return &#123;&#125; &#125;, mounted() &#123; this.initVideo() &#125;, destroyed() &#123; // 卸载组件的时候清除掉 video 的实例 this.player1.dispose() &#125;, methods: &#123; initVideo() &#123; videojs.options.flash.swf = 'https://vjs.zencdn.net/swf/5.3/video-js.swf' this.player1 = videojs('myVideo', &#123; bigPlayButton: false, textTrackDisplay: false, posterImage: false, errorDisplay: false, controlBar: false &#125;) this.player1.play() &#125; &#125;&#125;&lt;/script&gt; 好，到这里就完成 video.js 播放RTMP流的步骤 如果你使用的 React 的话，代码和你这个类似主要是语法变下就行了。 源代码koa-fe-vue 如果对你有帮助，麻烦帮忙点下 ✨(star) 参考链接video官网]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>Video.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS</tag>
        <tag>Vue</tag>
        <tag>Video.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上传图片预览]]></title>
    <url>%2Fmy-blog%2F2019%2F04%2F26%2F%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%A2%84%E8%A7%88%2F</url>
    <content type="text"><![CDATA[兼容IE6的图片预览 12345678910111213141516171819202122232425262728293031【html代码】：&lt;input id=&quot;file_upload&quot; type=&quot;file&quot; /&gt;&lt;div class=&quot;image_container&quot;&gt; &lt;img id=&quot;preview&quot; width=&quot;60&quot; height=&quot;60&quot;&gt;&lt;/div&gt;代码如下利用html5实现:几乎兼容所有主流浏览器，当然IE必须是IE 6以上【jquery代码】$(function() &#123; $(&quot;#file_upload&quot;).change(function() &#123; var $file = $(this); var fileObj = $file[0]; var windowURL = window.URL || window.webkitURL; var dataURL; var $img = $(&quot;#preview&quot;); if(fileObj &amp;&amp; fileObj.files &amp;&amp; fileObj.files[0])&#123; dataURL = windowURL.createObjectURL(fileObj.files[0]); $img.attr(&apos;src&apos;,dataURL); &#125;else&#123; dataURL = $file.val(); var imgObj = document.getElementById(&quot;preview&quot;); // 两个坑: // 1、在设置filter属性时，元素必须已经存在在DOM树中，动态创建的Node，也需要在设置属性前加入到DOM中，先设置属性在加入，无效； // 2、src属性需要像下面的方式添加，上面的两种方式添加，无效； imgObj.style.filter = &quot;progid:DXImageTransform.Microsoft.AlphaImageLoader(sizingMethod=scale)&quot;; imgObj.filters.item(&quot;DXImageTransform.Microsoft.AlphaImageLoader&quot;).src = dataURL; &#125; &#125;);&#125;); 12345678910111213141516171819202122232425262728293031323334353637383940//原生ajaxvar xhr = new XMLHttpRequest();//发送完成并成功事件xhr.onload = function() &#123; if (xhr.responseText == 1) &#123; //模态框提示 $(&quot;.modal-body&gt;.modal-main&quot;).html(&quot;发布成功&quot;); myModal.modal(&quot;show&quot;); setTimeout(function() &#123; location.reload(true); &#125;, 1000); &#125; else &#123; //模态框提示 $(&quot;.modal-body&gt;.modal-main&quot;).html(&quot;发布失败&quot;); myModal.modal(&quot;show&quot;); &#125;&#125;;//提交失败事件xhr.onerror = function() &#123; //模态框提示 $(&quot;.modal-body&gt;.modal-main&quot;).html(&quot;发布失败&quot;); myModal.modal(&quot;show&quot;);&#125;;//post方式提交，异步xhr.open(&apos;post&apos;, JSV.PATH_SERVER + &apos;Index/post_file&apos;, true);//设置头部信息（post方式必须）xhr.setRequestHeader(&apos;X-Request-With&apos;, &apos;XMLHttpRequest&apos;);//获取files对象var uploadFileBtn = $(&quot;#uploadFileBtn&quot;);var filesObj = uploadFileBtn[0].files;// //通过FormData来构建提交文件数据var formData = new FormData();//调用 append(name，value) 方法并传入相应的 File 对象作为参数(假设只有一个上传文件)formData.append(&quot;photo&quot;, filesObj[0]);var formTextData = requestData(formObj);for (var key in formTextData) &#123; formData.append(key, formTextData[key]);&#125;//将formData作为参数调用send()方法xhr.send(formData); 现代主流浏览器(IE10+):参考高三123456789101112131415161718192021222324252627282930// 【html代码】：&lt;input id=&quot;file_upload&quot; type=&quot;file&quot; /&gt;&lt;div class=&quot;image_container&quot;&gt; &lt;img id=&quot;preview&quot; width=&quot;60&quot; height=&quot;60&quot;&gt;&lt;/div&gt;// 【js代码】：// 1. 将图片转为base64,可将base64作为ajax传送数据var upload=document.querySelector(&quot;#file_upload&quot;);var preview=document.querySelector(&quot;#preview&quot;);upload.onchange=function()&#123; var file=this.files; var reader = new FileReader(); var (var i=0,len=files.length;i++)&#123; reader.readAsDataURL(target.files[i]); reader.onload =function(e)&#123; preview.src=reader.result; &#125;; &#125;&#125;// 2.使用对象urlvar upload=document.querySelector(&quot;#file_upload&quot;);var preview=document.querySelector(&quot;#preview&quot;);upload.onchange=function()&#123; var file=this.files; var windowUrl=window.URL || window.webkitURL; var (var i=0,len=files.length;i++)&#123; preview.src=windowUrl.createObjectURL(files[i]); &#125;&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fmy-blog%2F2019%2F04%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[跨域]]></title>
    <url>%2Fmy-blog%2F2019%2F04%2F26%2F%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[一个域名地址的组成 协议 子域名 主域名 端口号 请求资源地址 http:// www .abc.com :8080 /script/jquery.js 当协议、子域名、主域名、端口号任意一个不相同时，都算作不同域js在不同的域之间进行数据传输或通信，就算作跨域（比如用ajax向一个不同的域请求数据，或者通过js获取页面中不同域的框架中(iframe)的数据 ） 跨域方法1. frame之间（主域和子域或不同子域间）默认情况下，跨域的frame之间不能访问彼此的window对象上的方法和属性。 情况1：www.a.com 和 child.a.com的互相访问彼此window对象上的方法和属性：解决办法：将两个页面的document.domain设成相同的域名（只能设置成自身或更高一级的父域，且主域必须相同，如a.com或www.a.com，必须显式设置，即使域名与设置值相同） 情况2：在www.a.com页面通过ajax直接请求child.a.com：解决办法：即使设置了相同的document.domain（只适用于不同子域的框架间的交互）也不行。除了使用jsonp，还可以用一个隐藏的iframe来做代理（与child.a.com同域），通过该iframe请求child.a.com的数据，设置www.a.com和iframe的document.domain为相同域名。然后www.a.com访问iframe从child.a.com获取到的数据。 2. 服务器代理3. JSONP- 利用script标签，将其src当做请求地址，只要地址返回的是json或js步骤：- 创建script标签，src指向请求地址，在创建的script标签前声明函数fn：function fn(json){ alert(json) }- 请求地址返回fn({data:”返回的数据”})限制：- 只能用作get请求 123456789101112131415161718192021222324252627282930313233function jsonp(url,data,cbMap,dataCallback)&#123; // 时间戳 var timestamp=new Date().getTime(); // 创建script元素 var script=document.createElement("script"); var callbackName; for(var cb in cbMap)&#123; url +="?" + cb + "=" + (callbackName = cbMap[cb]) ; &#125; for(var key in data)&#123; url+="&amp;"+key+"="+data[key]; &#125; cb = key = null; //加上时间戳 url+="&amp;"+timestamp; //通过jsonp取得数据，然后执行回调 window[callbackName]=function (response)&#123; //response已获取，调用回调函数，并将response作为默认参数传入 dataCallback.call(window,response); delete window[callbackName]; &#125; script.src = url; //插入script元素 document.getElementsByTagName("body")[0].appendChild(script); //删除script元素 document.getElementsByTagName("body")[0].removeChild(script); //清除无用变量 script = null;&#125;// 回调函数名为“getData”，传给后台的相应字段为“callback”jsonp("https://www.baidu.com",&#123;&#125;,&#123;callback:"getData"&#125;,function(data)&#123; //取得数据后的回调&#125;) 4. 利用location.hash和iframe：- 详见《前端跨域整理 Damonare的个人博客.png》 5. 利用window.name和iframewindow对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。 情况1：www.a.com/a.html访问www.b.com/b.html下页面的数据： 解决办法： 设置www.b.com/b.html页面的window.name（只能为字符串） 在www.a.com/a.html页面创建一个隐藏的iframe，将src设为 www.b.com/b.html。此时iframe的window对象的name属性值即为www.b.com/b.html设置的值 修改iframe的src为www.a.com/a.html(该页面未设置window.name，即iframe的window对象的name属性值未改变) 然后www.a.com/a.html就可以访问iframe的window对象的name属性 123// www.b.com/b.htmlwindow.name = 'a.html要获取的数据'; 12345678910111213141516171819// www.a.com/a.htmlfunction getDataFrom(url) &#123; // 创建iframe代理 var iframe = document.createElement('iframe'); // 先设置src为访问地址路径 iframe.src = url; document.body.appendChild(iframe); var data; iframe.onload = function () &#123; // 获取iframe中window.name的值，即 www.b.com/b.html 设置的window.name data = iframe.contentWindow.name; // 移除代理iframe document.body.removeChild(iframe); &#125; // 修改iframe的src为与当前页面同域的路径（about:blank也行） iframe.src = 'ab.html'; return data;&#125; 6. CORS- H5提供的XMLHttpRequest Level2已经实现了跨域在服务端设置如下头部信息即可： header(‘Access-Control-Allow-Origin: * ‘); header(‘Access-Control-Allow-Methods: POST,GET ‘);- 兼容性：IE10+- 低版本IE可使用XDomainRequest对象实现跨域，用法同XMLHttpRequest 7. window.postMessage()- 详见《前端跨域整理 Damonare的个人博客.png》 参考： 浏览器的同源策略 HTTP访问控制(CORS) js中几种实用的跨域方法原理详解 前端跨域整理 http://bbs.miaov.com/forum.php?mod=viewthread&amp;tid=5551 前端跨域请求原理及实践 js中几种实用的跨域方法原理详解 Ajax跨域、Json跨域、Socket跨域和Canvas跨域等同源策略限制的解决方法]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS懒加载]]></title>
    <url>%2Fmy-blog%2F2019%2F04%2F26%2F%E5%8E%9F%E7%94%9FJS%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[原生JS懒加载 先理解图片的加载过程，一般在网页中如果 &lt;img /&gt; 这个标签中src属性中没得值，那图片就不会加载，所以我们可以利用这点。 知道了图片加载的方式，我们还需要了解一个知识点就是我们所看到的视口大小，这样才能算出来图片加载多少。 最后就一步整个代码的实现 JavaScript 中获取dom元素高度和宽度的方法 网页可见区域宽： document.body.clientWidth 网页可见区域高： document.body.clientHeight 网页可见区域宽： document.body.offsetWidth (包括边线的宽) 网页可见区域高： document.body.offsetHeight (包括边线的高) 网页正文全文宽： document.body.scrollWidth 网页正文全文高： document.body.scrollHeight 网页被卷去的高： document.body.scrollTop 网页被卷去的左： document.body.scrollLeft 12345678910111213141516171819202122// html部分&lt;img src=&quot;&quot; data-src=&quot;1.png&quot;&gt;&lt;img src=&quot;&quot; data-src=&quot;2.png&quot;&gt;&lt;img src=&quot;&quot; data-src=&quot;3.png&quot;&gt;&lt;img src=&quot;&quot; data-src=&quot;4.png&quot;&gt;// JS部分var aImg = document.querySelectorAll(&apos;img&apos;);var len = aImg.length;var n = 0;window.onscroll = function() &#123; var seeHeight = document.documentElement.clientHeight; var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; for (var i = n; i &lt; len; i++) &#123; if (aImg[i].offsetTop &lt; seeHeight + scrollTop) &#123; if (aImg[i].getAttribute(&apos;src&apos;) == &apos;&apos;) &#123; aImg[i].src = aImg[i].getAttribute(&apos;data-src&apos;); &#125; n = i + 1; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锚点]]></title>
    <url>%2Fmy-blog%2F2019%2F04%2F26%2F%E9%94%9A%E7%82%B9%2F</url>
    <content type="text"><![CDATA[锚点的实现方法大概有三种 使用a标签中的href属性123456789101112&lt;html&gt; &lt;body&gt; &lt;h2&gt; &lt;a href=&quot;#div1&quot;&gt;to div1&lt;/a&gt; &lt;a href=&quot;#div2&quot;&gt;to div2&lt;/a&gt; &lt;a href=&quot;#div3&quot;&gt;to div3&lt;/a&gt; &lt;/h2&gt; &lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;div2&lt;/div&gt; &lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 这种方法的缺点就是会改变URL的值。 使用js中的scrollIntoView()这个方法123456789&lt;html&gt; &lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;div2&lt;/div&gt; &lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt; &lt;script&gt; document.getElementById(&quot;div(Id)&quot;).scrollIntoView(); &lt;/script&gt;&lt;/html&gt; 这种方法的好处，是URL不会变，同时能够响应相应的scroll事件，不需要算法什么的。 记住要在div上加高度，不然会出现定位不准]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[容器长宽比]]></title>
    <url>%2Fmy-blog%2F2019%2F04%2F26%2F%E5%AE%B9%E5%99%A8%E9%95%BF%E5%AE%BD%E6%AF%94%2F</url>
    <content type="text"><![CDATA[A1: 使用背景图片实现长度比固定 (background)知识点： padding的%值是根据元素的width进行计算的 做法： 容器的height为0 容器的box-sizing为border-box，或者容器不能带有border 设置padding-bottom或padding-top为%值。比如：容器要比例为16:9，则padding-bottom或padding-top设为9 / 16 * 100% = 56.25% 注意： 图片长宽比要和容器长宽比相同，才能做到背景充满容器 代码：12&lt;div class="aspect-ratio-box"&gt;&lt;/div&gt; 12345678/* 16:9 */.aspect-ratio-boxes&#123; overflow: hidden; /* 不确定这个属性什么用 */ height: 0; padding-top: 56.25%; background: url(/images/happy-birthday.png) no-repeat center; background-size: contain;&#125; A2: 适用与img、video、iframe或object的方案知识点： 同A1第1条 定位 做法： 同A1第1、2、3条 容器relative定位，元素（img、video等）absolute定位 代码：12345678&lt;div class="aspect-ratio-box"&gt; &lt;iframe class="aspect-ratio-box-inside" src="https://www.youtube.com/embed/upPCohrJcbw?showinfo=0&amp;modestbranding=1" frameborder="0" allowfullscreen&gt; &lt;/iframe&gt; &lt;/div&gt; 1234567891011121314.aspect-ratio-box &#123; height: 0; overflow: hidden; /* 不确定这个属性什么用 */ padding-top: calc(591.44 / 1127.34 * 100%); background: white; position: relative; &#125; .aspect-ratio-box-inside &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; &#125; B1: 利用伪类(:before、:after)实现知识点： 伪类 浮动 margin可以设置负值 做法： 容器伪类元素设置padding-top按比例计算的%值 代码： 12345&lt;div class="aspect-ratio-box"&gt; &lt;div class="aspect-ratio-box-inside"&gt; bala..bala.... &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536.aspect-ratio-box &#123; background: orange; max-width: 50vw; margin: 20px auto;&#125;/* 伪类+浮动：内容不超过容器时，保持长宽比；超出时，自动扩展高度 */.aspect-ratio-box::before &#123; content: ""; width: 1px; margin-left: -1px; float: left; height: 0; padding-top: calc(591.44 / 1127.34 * 100%);&#125;.aspect-ratio-box::after &#123; /* to clear float */ content: ""; display: table; clear: both;&#125;/* 伪类+定位 */.aspect-ratio-box::before &#123; content: ''; position: relative; display: block; box-sizing: border-box; padding-top: calc(591.44 / 1127.34 * 100%);&#125;.aspect-ratio-box-inside &#123; position: absolute; top: 0; bottom: 0; left: 0; right: 0;&#125; C1: 使用CSS自定义属性知识点： CSS自定义属性 代码：1234567&lt;div style="--aspect-ratio:16/9"&gt; &lt;iframe src="https://www.youtube.com/embed/upPCohrJcbw?showinfo=0&amp;modestbranding=1" frameborder="0" allowfullscreen=""&gt; &lt;/iframe&gt;&lt;/div&gt; 12345678910111213141516171819202122232425:root &#123; --aspect-ratio: 1 / 1;&#125;[style*="--aspect-ratio"] &gt; :first-child &#123; width: 100%;&#125;[style*="--aspect-ratio"] &gt; * &#123; height: auto;&#125; @supports (--custom:property) &#123; [style*="--aspect-ratio"] &#123; position: relative; &#125; [style*="--aspect-ratio"]::before &#123; content: ""; display: block; padding-bottom: calc(100% / (var(--aspect-ratio))); &#125; [style*="--aspect-ratio"] &gt; :first-child &#123; position: absolute; top: 0; left: 0; height: 100%; &#125; &#125; 参考： 容器长宽比 CSS实现长宽比的几种方案 demo]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5学习整理]]></title>
    <url>%2Fmy-blog%2F2019%2F04%2F26%2FHTML5%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[HTML5 学习整理 HTML5 是 W3C 与 WHATWG 合作的结果,WHATWG 指 Web Hypertext Application Technology Working Group。 WHATWG 致力于 web 表单和应用程序，而 W3C 专注于 XHTML 2.0。在 2006 年，双方决定进行合作，来创建一个新版本的 HTML HTML5 中的一些有趣的新特性： 用于绘画的 canvas 元素 用于媒介回放的 video 和 audio 元素 对本地离线存储的更好的支持。 新的特殊内容元素，比如 article 、footer 、header 、nav 、section 新的表单控件，比如：calendar 、date、time、email、url、search 注意：对于中文网页需要使用&lt;meta charset=&quot;utf-8&quot;&gt;声明编码，否则会出现乱码。 标签 描述 &lt;article&gt; 定义页面独立的内容区域 &lt;aside&gt; 定义页面的侧边栏内容 &lt;bdi&gt; 允许您设置一段文本，使其脱离其父元素的文本方向位置。 &lt;command&gt; 定义命令按钮，比如单选按钮、复选框、或按钮 &lt;details&gt; 用于描述文档或文档某个部分的细节 &lt;dialog&gt; 定义对话框，比如提示框 &lt;summary&gt; 标签包含 details 元素的标题 &lt;figure&gt; 规定独立的流内容（图像、图表、照片、代码等等） &lt;figcaption&gt; 定义 &lt;figure&gt; 元素的标题 &lt;footer&gt; 定义 section 或 document 的页脚 &lt;header&gt; 定义了文档的头部区域 &lt;mark&gt; 定义带有记号的文本 &lt;meter&gt; 定义度量衡。仅用于已知最大和最小值的度量。 &lt;nav&gt; 定义导航链接的部分 &lt;progress&gt; 定义任何类型的任务的进度 &lt;ruby&gt; 定义 ruby 注释（中文注音或字符） &lt;rt&gt; 定义字符（中文注音或字符）的解释或发音 &lt;rp&gt; 在 ruby 注释种使用，定义不支持 ruby 元素的浏览器所显示的内容 &lt;section&gt; 定义文档种的节（section、区段） &lt;time&gt; 定义日期或者时间 &lt;wbr&gt; 规定在文本种的何处适合添加换行符]]></content>
      <categories>
        <category>前端</category>
        <category>Html5</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数组的基本方法]]></title>
    <url>%2Fmy-blog%2F2019%2F04%2F26%2FJS%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JS 数组中的基本方法整理 方法 描述 返回值 concat() 连接两个或更多的数组，并返回结果 原数组 indexOf() 搜索数组中的元素，并返回它所在的位置 原数组 join() 把数组的所有元素放入一个字符串 原数组 lastIndexOf 返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索 原数组 reverse() 反转数组的元素顺序 原数组 sort() 对数组的元素进行排序 原数组 slice() 选取数组的的一部分 新的字符串 toString() 把数组转换为字符串，并返回结果 Boolean valueOf() 返回数组对象的原始值 原数组 forEach() 循环、遍历数组 原数组 splice() 从数组中添加、删除、替换元素 新数组 pop() 删除数组的最后一个元素 返回删除的元素 push() 向数组的末尾添加一个或更多元素 返回新的长度 shift() 删除数组的第一个元素 返回第一个元素的值 unshift() 向数组的开头添加一个或更多元素 返回新的长度 every() 检测数组元素的每个元素是否都符合条件 Boolean some() 检测数组元素中是否有元素符合指定条件 Boolean es6中新增 方法 描述 返回值 set() 成员都是唯一的，没有重复的值 构造函数 map() 循环、遍历数组 新数组 Array.from() 将两类对象转为真正的数组: 类似数组的对象和可遍历的对象(包括es6的Set和map) 新数组 Array.of() 将一组值，转换为数组 新数组 find() 检测数组元素中是否有元素符合指定条件 Boolean或undefind findIndex() 检测数组元素中是否有元素符合指定条件 Number或 -1 Array.fill() 填充数组 新数组 Array.includes() 检测数组元素中是否有元素符合指定条件 Boolean Array.flat() 将嵌套的数组“拉平” 新数组]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组去重的各种姿势]]></title>
    <url>%2Fmy-blog%2F2019%2F04%2F26%2F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[最常用的几种方法 目前我只能想到数组中纯数字、数字加字符串、对象，所以写了几个个人觉得还可以用的方法作为记录 数组中全是数字的去重方法 最简单 - 纯数字 1234567891011121314// 注意： IE8 是不支持indexOf方法// 新建一数组，遍历传入数组的值，值不在新数组就 push 到新数组里function unique(arr) &#123; let newArr = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (newArr.indexOf(arr[i]) == -1 ) &#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;let a = [1, 1, 2, 3, 4, 3];console.log(unique(a)); // [1, 2, 3, 4] 数组下标法 - 数字、字符串 12345678910111213// 实现思路：如果当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的，忽略掉。否则存入结果数组function unique(arr) &#123; let newArr = []; for(let i = 0; i &lt; arr.length; i++) &#123; if(arr.indexOf(arr[i]) === i)&#123; newArr.push(arr[i]) &#125; &#125; return newArr;&#125;let a = [1, 1, 2, 3, 'a', 'a'];console.log(unique(a)); ES6的写法 12let a = [1, 1, 2, 3, 4, 3];console.log(Array.from(new Set(a))); // [1, 2, 3, 4] 前面都是的数组中全是数字，现在来看看数组中是对象的情况 12345678910111213141516171819202122232425// 这是我们的数据let arr = [ &#123; name: &apos;xiaoming&apos;, id: 1 &#125;, &#123; name: &apos;xiaohong&apos;, id: 1 &#125;, &#123; name: &apos;xiaozhang&apos;, id: 2 &#125;]// reducelet obj = &#123;&#125;;let newArr = arr.reduce((cur, next) =&gt; &#123; obj[next.id] ? &apos;&apos; : obj[next.id] = true &amp;&amp; cur.push(next); return cur;&#125;, [])console.log(newArr);]]></content>
      <categories>
        <category>前端</category>
        <category>数组去重</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的交集、并集、差集]]></title>
    <url>%2Fmy-blog%2F2019%2F04%2F25%2FJS%E4%B8%AD%E7%9A%84%E4%BA%A4%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86%2F</url>
    <content type="text"><![CDATA[前言 写在前面，前段时间写项目遇到一个很棘手的问题，求数组内容里全是对象的交集，这个需求说难并不是很难，但是我还是花了一个小时才想明白怎么做 数组里全数字的交集、并集、差集 数组里面的全数字的交集其实很简单，如果你有认真的看下 这篇文章，其中就有讲到数组中全数字怎么得到交集、并集、差集，如果你没有仔细看，那请看下我怎么实现的。 123456789101112131415// 定义两个数组let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; 但是从打印的地方来看，我们得到的并不是我们想要的数组结构，这里有两种变通的方法可以解决， 利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构 1234// 方法一let set = new Set([1, 2, 3]);set = new Set([...set].map(val =&gt; val * 2));// set的值是2, 4, 6 利用ES6的 Array.form 方法 1234// 方法二let set = new Set([1, 2, 3]);set = new Set(Array.from(set, val =&gt; val * 2));// set的值是2, 4, 6 这里个人推荐的是第二种方法 数组里全对象的交集、并集、差集 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647let arr1 = [ &#123; name: &apos;xiaoming&apos;, id: 1 &#125;, &#123; name: &apos;xiaohong&apos;, id: 2 &#125;]let arr2 = [ &#123; name: &apos;xiaoming&apos;, id: 1 &#125;, &#123; name: &apos;xiaohong&apos;, id: 2 &#125;, &#123; name: &apos;xiaozhang&apos;, id: 3 &#125;]// 并集let arr3 = arr1.concat(arr2)let obj = []let result = arr3.reduce((cur, next) =&gt; &#123; obj[next.id] ? &apos;&apos; : obj[next.id] = true &amp;&amp; cur.push(next) return cur&#125;, [])console.log(result)// 交集let arrId = arr1.map(m =&gt; m.id)let result = arr2.filter(v =&gt; arrId.includes(v.id))console.log(result)// 差集let arr1Id = arr1.map(m =&gt; m.id)let arr2Id = arr2.map(m =&gt; m.id)let arr3 = arr1.concat(arr2)let result = arr3.filter(v =&gt; !(arr1Id.includes(v.id)) || !(arr2Id.includes(v.id)))console.log(result) 友情链接ECMAScript 6入门 - 阮一峰]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-hooks尝鲜]]></title>
    <url>%2Fmy-blog%2F2019%2F04%2F24%2Freact-hooks%E5%B0%9D%E9%B2%9C%2F</url>
    <content type="text"><![CDATA[what is a Hooks?Hooks是指函数组件“hook into”反应状态和生命周期特性的函数。Hooks在类中不起作用，它可以在没有类的情况下直接使用React。（不建议重写现有组件，可以在新的组件中使用Hooks） 钩子一瞥 钩子是在React 16.8中新增的。它们允许您在不编写类的情况下使用状态和其他反应特性。 State Hook 🌰 点击按钮自增数 之前的写法 12345678910111213141516171819202122232425import React, &#123; Component &#125; from &apos;react&apos;class App extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; count: 0 &#125; &#125; render() &#123; const &#123; count &#125; = this.state; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: count + 1 &#125;)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default App; 用了 hooks 的写法 123456789101112131415import React, &#123; useState &#125; from &apos;react&apos;function App() &#123; const [count, setCount] = useState(0) return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;export default App useState 是一个钩子，我们在一个函数组件内部调用它来向它添加一些本地的状态 react将在重新渲染之间保留这个状态 useState 返回一对数据：当前状态值和一个允许更新它的函数，可以从时间处理或者其他地方调用这个返回函数，类似 this.setState，不同的是它不将新旧状态合并在一起 还有一点需要注意, useState 的唯一参数是初始状态，在上面的栗子中，它的初始状态是0。与 this.state 不同：这里的状态不一定是一个对象；且初始状态参数仅在第一次期间使用 🌰 声明多个状态变量 1234567function ExampleWithManyStates() &#123; // Declare multiple state variables! const [age, setAge] = useState(42); const [fruit, setFruit] = useState(&apos;banana&apos;); const [todos, setTodos] = useState([&#123; text: &apos;Learn Hooks&apos; &#125;]); // ...&#125; React 提供类一些内置的钩子，比如刚才使用的 useState ，也可以自己创建钩子来重用不同组件之间的状态行为。 Effect Hook Effect Hook，它与componentDidMount、componentDidUpdate和componentWillUnmount的作用相同 栗子 更新DOM后设置文档标题 之前的写法 12345678910111213141516171819202122232425262728293031323334353637import React, &#123; Component &#125; from &apos;react&apos;class App extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; count: 0 &#125; &#125; componentDidMount() &#123; const &#123; count &#125; = this.state document.title = `You clicked $&#123;count&#125; times` &#125; componentDidUpdate() &#123; const &#123; count &#125; = this.state document.title = `You clicked $&#123;count&#125; times` &#125; render() &#123; const &#123; count &#125; = this.state; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: count + 1 &#125;)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default App; 使用了 Hooks 1234567891011121314151617181920import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function Example() &#123; const [count, setCount] = useState(0); // Similar to componentDidMount and componentDidUpdate: useEffect(() =&gt; &#123; // Update the document title using the browser API document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 默认情况下，React 会在每次渲染后调用副作用函数（包括第一次渲染） 副作用函数还可以通过返回一个函数来指定如何“清除”副作用。它的执行顺序是，每次页面更新前，先执行 return 函数，然后再执行 useEffect 里的内容 跟 useState 一样，可以在组件中多次使用 useEffect ，通过使用 Hooks，你可以把组件内相关的副作用函数组织在一起，（比如创建订阅和取消订阅），这样的好处在于不用把它们拆分在不同的生命周期函数里面 useEffect 还可以传入第二个参数，指定某个值发生变化的时候才触发 123useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`;&#125;, [count]) 如果只想运行一次 useEffect，可以把第二个参数改为一个空数组 ⚠️ Rules of Hooks Hooks 是属于 JavaScript 函数，但是他们还附加了两条规则 只有顶层才能使用 Hooks， 不要在循环、条件、或者嵌套函数内调用挂钩 只有在 React 函数组件中调用挂钩，不要从常规的 JavaScript 函数调用钩子。（只有一个有效地方可以调用钩子 - 自定义钩子） 自定义钩子 很多时候我们的组件都会存在状态逻辑的重用，在传统上，我们会用到两种比较流行的解决方案： 高阶组件 渲染道具但是现在出现了 Hooks，我们可以自定义一些钩子函数，且它不会向树中添加更多的组件 首先，我们自定义一个重用的函数钩子 123456789101112131415161718import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); &#125;; &#125;); return isOnline;&#125; 以 friendID 作为参数，放回我们的朋友是否在线 然后其他组件可以这样使用它： 🌰 1 12345678function FriendStatus(props) &#123; const isOnline = useFriendStatus(props.friend.id); if (isOnline === null) &#123; return &apos;Loading...&apos;; &#125; return isOnline ? &apos;Online&apos; : &apos;Offline&apos;;&#125; 🌰 2 123456789function FriendListItem(props) &#123; const isOnline = useFriendStatus(props.friend.id); return ( &lt;li style=&#123;&#123; color: isOnline ? &apos;green&apos; : &apos;black&apos; &#125;&#125;&gt; &#123;props.friend.name&#125; &lt;/li&gt; );&#125; 这些组件的状态完全独立 钩子是一种重用有状态逻辑的方法，而不是状态本身 每个调用钩子的函数都是完全独立的状态，所以可以在一个组件中使用同一个自定义钩子两次 自定义的钩子函数注意：需要以“use”开头并调用其他的钩子useSomething，这样方便linter插件如何使用钩子在代码中查找错误 其他钩子 useContext 接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定 useReducer useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。（如果你熟悉 Redux 的话，就已经知道它如何工作了。） 🌰 reducer.js1234567891011121314151617181920212223const initialState = &#123;count: 0&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case &apos;increment&apos;: return &#123;count: state.count + 1&#125;; case &apos;decrement&apos;: return &#123;count: state.count - 1&#125;; default: throw new Error(); &#125;&#125;function Counter(&#123;initialState&#125;) &#123; const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;increment&apos;&#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;decrement&apos;&#125;)&#125;&gt;-&lt;/button&gt; &lt;/&gt; );&#125; 完整 demo 请点击我 使用以前最好看下 官方文档因为中文React文档还没有更新到最新的版本，所以我也是看的英文的文档]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS</tag>
        <tag>React</tag>
        <tag>react-hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你用webpack4搭建react框架（优化篇）]]></title>
    <url>%2Fmy-blog%2F2019%2F04%2F24%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8webpack4%E6%90%AD%E5%BB%BAreact%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BC%98%E5%8C%96%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[使用webpack4搭建react 第二章 这篇属于优化篇，基础篇请前往这里 点击我 整合html-webpack-plugin 主要是 public - index.html 这个文件需要自己主动生成，且js也是自己添加，所以我们用到了这个插件 首先下载插件 yarn add html-webpack-plugin -D 然后在 build - webpack.prod.config.js 这个文件中配置plugin 12345678910111213141516171819const merge = require(&apos;webpack-merge&apos;)const baseWebpackConfig = require(&apos;./webpack.base.config&apos;)// html-webpack-plugin其他参数 https://webpack.docschina.org/plugins/html-webpack-plugin/#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)module.exports = merge(baseWebpackConfig, &#123; mode: &apos;production&apos;, plugins: [ new HtmlWebpackPlugin(&#123; template: &apos;public/index.html&apos;, inject: &apos;body&apos;, minify: &#123; // 其他参数 https://github.com/kangax/html-minifier#options-quick-reference removeComments: true, // 剥离HTML评论 collapseWhitespace: true, // 折叠有助于文档树中文本节点的空白区域 removeAttributeQuotes: true // 尽可能删除属性周围的引号 &#125; &#125;) ]&#125;) 测试一下，先删除 index.html 中的 script 标签 重新编译一次 yarn run build，编译完以后结果如下然后目录中会多出一个 index.html 文件这样感觉层级不是很友好，所以我们需要再改下目录的层级，找到 webpack.base.config.js 修改 output 中代码1234output: &#123; filename: &apos;js/bundle.js&apos;, // 这里是做一个修改 path: OUTPUT_PATH&#125;, 再重新编译一下，执行 yarn run build 就可以了 写代码的时候可能会出现文件或者文件夹名字重复的问题，所以我们这是需要用到 hash；更重要的一点是解决浏览器缓存的问题找到 webpack.base.config.js 修改 output 中代码 1234output: &#123; filename: &apos;js/[name].[chunkhash:16].js&apos;, // 这里是做一个修改 path: OUTPUT_PATH&#125;, 刚才提到文件重复的问题，这里还有一个解决方案就是每次编译以前先清理dist目录，如果不清理的话，会导致文件很多且内容其实是一样，为什么会这样，原因就是因为我们加入了hash所以导致里面的文件会很多 首先下载插件 yarn add clean-webpack-plugin -D 然后在 build - webpack.prod.config.js 这个文件中配置plugin123456789101112131415161718192021222324252627const merge = require(&apos;webpack-merge&apos;)// html-webpack-plugin https://webpack.docschina.org/plugins/html-webpack-plugin/#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)// clean-webpack-plugin https://webpack.docschina.org/guides/output-management/#%E6%B8%85%E7%90%86-dist-%E6%96%87%E4%BB%B6%E5%A4%B9const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;)const baseWebpackConfig = require(&apos;./webpack.base.config&apos;)module.exports = merge(baseWebpackConfig, &#123; mode: &apos;production&apos;, plugins: [ new HtmlWebpackPlugin(&#123; template: &apos;public/index.html&apos;, inject: &apos;body&apos;, minify: &#123; // 其他参数 https://github.com/kangax/html-minifier#options-quick-reference removeComments: true, // 剥离HTML评论 collapseWhitespace: true, // 折叠有助于文档树中文本节点的空白区域 removeAttributeQuotes: true // 尽可能删除属性周围的引号 &#125; &#125;), new CleanWebpackPlugin(&#123; // 其他参数 https://github.com/johnagan/clean-webpack-plugin#options-and-defaults-optional dry: true, verbose: true &#125;) ]&#125;) 编译一下 yarn run build 抽离业务代码 为什么抽离，原因很简单，我们不可能每次都去编译不变的代码，比如：react、react-dom等，所以我们需要抽离这些 首先我们需要在 webpack.base.config.js 再添加一个入口文件123456789101112131415161718192021222324252627const path = require(&apos;path&apos;) // path是属于node的一个模块const OUTPUT_PATH = path.resolve(__dirname, &apos;../dist&apos;)const APP_PATH = path.resolve(__dirname, &apos;../src&apos;)module.exports = &#123; entry: &#123; app: &apos;./src/index.js&apos;, // 以下为新增 react: [ &apos;react&apos;, &apos;react-dom&apos; ] &#125;, output: &#123; filename: &apos;js/[name].[chunkhash:16].js&apos;, path: OUTPUT_PATH &#125;, module: &#123; rules: [ &#123; test: /\.js?$/, use: &apos;babel-loader&apos;, include: [APP_PATH] &#125; ] &#125;&#125; 我们在重新打包一下，得确是另外打了一个包出来，但细心的你可能会发现 app.js 并没有减少，这里 webpack4 使用配置 optimization.splitChunks 的方式来抽离代码1234567891011121314151617181920212223242526272829303132333435363738394041const merge = require(&apos;webpack-merge&apos;)// html-webpack-plugin https://webpack.docschina.org/plugins/html-webpack-plugin/#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)// clean-webpack-plugin https://webpack.docschina.org/guides/output-management/#%E6%B8%85%E7%90%86-dist-%E6%96%87%E4%BB%B6%E5%A4%B9const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;)const baseWebpackConfig = require(&apos;./webpack.base.config&apos;)module.exports = merge(baseWebpackConfig, &#123; mode: &apos;production&apos;, optimization: &#123; splitChunks: &#123; chunks: &apos;all&apos;, minChunks: 1, minSize: 0, cacheGroups: &#123; react: &#123; test: &apos;react&apos;, name: &apos;react&apos;, enforce: true &#125; &#125; &#125; &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &apos;public/index.html&apos;, inject: &apos;body&apos;, minify: &#123; // 其他参数 https://github.com/kangax/html-minifier#options-quick-reference removeComments: true, // 剥离HTML评论 collapseWhitespace: true, // 折叠有助于文档树中文本节点的空白区域 removeAttributeQuotes: true // 尽可能删除属性周围的引号 &#125; &#125;), new CleanWebpackPlugin(&#123; // 其他参数 https://github.com/johnagan/clean-webpack-plugin#options-and-defaults-optional dry: true, verbose: true &#125;) ]&#125;) 压缩文件 还是在 optimization 配置，不过这次我们需要用到一个插件 uglifyjs-webpack-plugin 下载插件 yarn add uglifyjs-webpack-plugin -D 引入插件 1const UglifyJSPlugin = require(&apos;uglifyjs-webpack-plugin&apos;) 配置插件 optimization - minimizer 123minimizer: [ new UglifyJSPlugin()], 重新编译一下 npm run build 配置本地开发环境 安装 yanr add webpack-dev-server -D 找到 build - webpack.dev.config.js 加入一下代码12345678910111213141516171819202122232425262728293031323334const path = require(&apos;path&apos;)const webpack = require(&apos;webpack&apos;)const merge = require(&apos;webpack-merge&apos;)const baseWebpackConfig = require(&apos;./webpack.base.config.js&apos;)const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)module.exports = merge(baseWebpackConfig, &#123; mode: &apos;development&apos;, output: &#123; filename: &apos;js/[name].[hash:16].js&apos;, &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &apos;public/index.html&apos;, inject: &apos;body&apos;, minify: &#123; html5: true, &#125;, hash: false, &#125;), new webpack.HotModuleReplacementPlugin(), ], devServer: &#123; port: &apos;8080&apos;, contentBase: path.join(__dirname, &apos;../public&apos;), compress: true, historyApiFallback: true, hot: true, // 热更新 并引入 HotModuleReplacementPlugin 插件 https: false, noInfo: true, open: true, proxy: &#123;&#125;, &#125;,&#125;) 有了本地服务，我们还需要热更新，先修改 devServer.hot: true并在plugins中引入 HotModuleReplacementPlugin 插件，开启热更新，记得替换hash 在 package.json 文件中增加一个npm scripts 1&quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.config.js&quot; 上面配置完成在命令行中输入 yarn run dev，就会自动开启本地服务]]></content>
      <categories>
        <category>webpack</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS</tag>
        <tag>React</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你用webpack4搭建react框架（基础篇）]]></title>
    <url>%2Fmy-blog%2F2019%2F04%2F23%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8webpack4%E6%90%AD%E5%BB%BAreact%E6%A1%86%E6%9E%B6%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[使用webpack4搭建react 第一章首先要先去了解下 webpack，基本的就不多再介绍了。 然后开始我们的 webpack 配置： 再命令行中输入 npm init,当然那也可以使用 npm init -y -y 的意义就不需要自己一个一个去填写。mkdir 创建文件夹，cd 进入文件夹，然后你看到生成 package.json 这个文件就成功了 然后新建一些文件，具体目录结构大致如下： 下载依赖，因为 webpack4.0 是把 webpack 和 webpack-cli 分开了 1234567// 这里我使用的是 facebook 的 yarn webpack-dev-server 本地启动项目的服务插件yarn add webpack webpack-cli webpack-dev-server -D// 如果你需要使用npmnpm install webpack webpack-cli -D 然后在 build 文件夹下找到 webpack.base.config.js 进行基础的配置， webpack4.0以上的版本增加了 mode 的模式。主要是用于不同的环境选项，有个高级的配置地址你可能需要了解一下 点击我 接着我们需要用到一个插件来组织下 webpack 的基础配置和不同环境，123456789yarn add webpack-merge -D// 下载成功来以后,我们打开 `webpack.prod.config.js` ，编辑代码const merge = require(&apos;webpack-merge&apos;)const baseWebpackConfig = require(&apos;./webpack.base.conf&apos;)module.exports = merge(baseWebpackConfig, &#123; mode: &apos;production&apos;&#125;) 然后分别在 src - index.js 的文件写入12var ele = document.getElementById(&apos;root&apos;)ele.innerHTML = &apos;hello world&apos; 然后在 public 新建一个index.html文件 写入12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;手把手教你用webpack4搭建react框架（基础篇）&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 然后就需要打包测试我们写的对不对了，在命令行中输入 webpack --config build/webpack.prod.config.js，虽然成功，但是感觉很麻烦，所以我们来改进下，找到根目录下的 package.json 文件，在命令行中输入 npm run build 结果和上面是一样的 安装react 在命令行中输入 yarn add react react-dom --save 安装完成以后我们在 src - index.js 文件直接使用react1234567import React from &apos;react&apos;import ReactDom from &apos;react-dom&apos;ReactDom.render( &lt;h1&gt;hello world&lt;/h1&gt;, document.getElementById(&apos;root&apos;)) 写入以上代码，然后执行打包 npm run build，这时会报错为啥会报错？因为 webpack 只识别JavaScript文件，而且只能编译es5版本的JavaScript语法。实际上，我们使用ES2015，以及jsx的语法糖，webpack它根本不认识。然后我们就需要用到 loader 来做预处理文件了。常用的就是 babel-loader 把ES2015+的语法转换成ES5的语法 安装babel 首先我们安装 babel 的模块，在命令行中输入yarn add babel-loader @babel/preset-react @babel/preset-env @babel/core -D，为啥会下这么多的包，因为其中@babel/core是babel 的核心模块，@babel/preset-env 是转译ES2015+的语法，@babel/preset-react是转译react的JSX以及FLOW，如果还有其他问题不了解的可以 进入官网 然后我们还需要在根目录下创建一个 .babelrc 的文件，用于配置 presets，1234567891011121314151617&#123; &quot;presets&quot;: [ [ &quot;@babel/preset-env&quot;, &#123; &quot;targets&quot;: &#123; &quot;browsers&quot;: [ &quot;&gt; 1%&quot;, &quot;last 5 versions&quot;, &quot;ie &gt;= 8&quot; ] &#125; &#125; ], &quot;@babel/preset-react&quot; ]&#125; API详情 接着我们再去载入babel-loader，修改 webpack.base.config.js 文件12345678910111213141516171819202122const path = require(&apos;path&apos;) // path是属于node的一个模块const APP_PATH = path.resolve(__dirname, &apos;../src&apos;)const DIST_PATH = path.resolve(__dirname, &apos;../dist&apos;)module.exports = &#123; entry: &#123; app: &apos;./src/index.js&apos; &#125;, output: &#123; filename: &apos;bundle.js&apos;, path: DIST_PATH &#125;, module: &#123; rules: [ &#123; test: /\.js?$/, use: &apos;babel-loader&apos;, include: APP_PATH &#125; ] &#125;&#125; 重新编译，就OK了。 最后我把项目的接口改了一下，大致是这样的基本的需求已经完成了。接下来会优化一下框架 然后源码在这里 base-first分支中]]></content>
      <categories>
        <category>webpack</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS</tag>
        <tag>React</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux、mobx优缺点]]></title>
    <url>%2Fmy-blog%2F2019%2F04%2F23%2Fredux%E3%80%81mobx%E4%BC%98%E7%BC%BA%E7%82%B9%2F</url>
    <content type="text"><![CDATA[函数式 与 面向对象 函数式编程的好处 无副作用，可时间回溯，适合并发。 数据流变换处理很拿手，比如 rxjs。 对于复杂数据逻辑、科学计算的开发和维护效率更高 面向对象的好处 javascript 的鸭子类型，表明它基于对象，不适合完全函数式表达。 数学思维和数据处理适合用函数式，技术是为业务服务的，而业务模型适合用面向对象。 业务开发和做研究不同，逻辑严谨的函数式相当完美，但别指望每个程序员都愿意消耗大量脑细胞解决日常业务问题。 redux redux 的优劣势 数据流流动很自然，因为任何 dispatch 都会导致广播，需要依据对象引用是否变化来控制更新粒度。 如果充分利用时间回溯的特征，可以增强业务的可预测性与错误定位能力。 时间回溯代价很高，因为每次都要更新引用，除非增加代码复杂度，或使用 immutable。 时间回溯的另一个代价是 action 与 reducer 完全脱节，数据流过程需要自行脑补。原因是可回溯必然不能保证引用关系。 引入中间件，其实主要为了解决异步带来的副作用，业务逻辑或多或少参杂着 magic。 但是灵活利用中间件，可以通过约定完成许多复杂的工作。 对 typescript 支持困难。 mobx redux 的优劣势 数据流流动不自然，只有用到的数据才会引发绑定，局部精确更新，但免去了粒度控制烦恼。 没有时间回溯能力，因为数据只有一份引用。 自始至终一份引用，不需要 immutable，也没有复制对象的额外开销。 没有这样的烦恼，数据流动由函数调用一气呵成，便于调试。 业务开发不是脑力活，而是体力活，少一些 magic，多一些效率。 由于没有 magic，所以没有中间件机制，没法通过 magic 加快工作效率（这里 magic 是指 action 分发到 reducer 的过程）。 完美支持 typescript。 本文详情链接]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>状态管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS原型和原型链]]></title>
    <url>%2Fmy-blog%2F2019%2F04%2F22%2FJS%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[原型和原型链知识点 构造函数 构造函数 - 扩展 原型规则和示例 原型链 instanceof 构造函数1234567function Foo(name, age) &#123; this.name = name this.age = age this.class = &apos;class-1&apos; // return this // 默认有这一行&#125;var f = nwe Foo(&apos;zhangsan&apos;, 20) // f就有Foo的属性 构造函数 - 扩展 var a = {} 其实是 var a = new Object() 的语法糖 var a = [] 其实是 vat a = nwe Array() 的语法糖 function Foo() {…} 其实是 var Foo = new Function(…) 使用 instanceof 判断一个函数是否是一个变量的构造函数 原型规则和示例5条原型规则 所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（除了”null”） 123var obj = &#123;&#125;; obj.a = 100;var arr = []; arr.a = 100;function fn() &#123;&#125;; fn.a = 100; 所有的引用类型（数组、对象、函数），都有一个proto属性，属性值是一个普通的对象 12345...console.log(obj.__proto__);console.log(arr.__proto__);console.log(fn.__proto__); 所有的函数，都有一个 prototype 属性，属性值也是一个普通对象 123...console.log(fn.prototype) 所有的引用类型（数组、对象、函数），proto属性值指向它的构造函数的 “prototype” 属性值 123...console.log(obj.__proto__ === Object.prototype) 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的proto（即它的构造函数的prototype）中寻找 123456789101112131415function Foo() &#123; this.name = name&#125;Foo.prototype.alertName = function() &#123; alert(this.name)&#125;var f = new Foo(‘food’)f.printName = function() &#123; console.log(this.name)&#125;f.printName() // foodf.alertName() // food 原型链123...f.toString() // f.__proto__.__proto__中查找 如果最上层没有的就是null 原型继承123456789101112131415161718192021222324252627// 封装DOM查询function Elem(id) &#123; this.elem = document.getElementById(id)&#125;Elem.prototype.html = function(val) &#123; var elem = this.elem if (val) &#123; elem.innerHTML = val return this // 链式操作 &#125; else &#123; return elem.innerHTML &#125;&#125; Elem.prototype.on = function(type, fn) &#123; var elem = this.elem elem.addEventListener(type, fn) return this&#125;let div1 = new Elem(&apos;div1&apos;)// console.log(div1.html())div1.html(&apos;&lt;p&gt;hello m&lt;/p&gt;&apos;).on(&apos;click&apos;, function() &#123; alert(&apos;clicked&apos;)&#125;)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-next主题使用随机背景图]]></title>
    <url>%2Fmy-blog%2F2019%2F04%2F19%2Fhexo%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E8%83%8C%E6%99%AF%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[在next中使用随机的背景图片 如果有小伙伴不想自己的页面太素了，可以加上这个背景图，每次都是随机的图片 图片来源 修改背景样式 找到这个 themes\next\source\css\ _custom\custom.styl 文件，这是 next 主题故意留下来用户自定义的文件，在文件中添加一下代码 1234567body &#123; background: url(https://source.unsplash.com/random/1600x900); background-repeat: no-repeat; background-attachment: fixed; background-position: 50% 50%; background-size: cover;&#125; 以上就是 hexo-next主题使用随机背景图]]></content>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建的博客中最优雅的放大图片的方法]]></title>
    <url>%2Fmy-blog%2F2019%2F04%2F18%2Fhexo%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%9C%80%E4%BC%98%E9%9B%85%E7%9A%84%E6%94%BE%E5%A4%A7%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[hexo搭建的博客中最优雅的放大图片的方法 写在前面，大家百度hexo放大图片的方法很多种所以我就讲最优雅的一种也是最好用的一种 cd next/source/lib 下载插件 git clone https://github.com/theme-next/theme-next-fancybox3 fancybox 更改next/_config.yml文件, fancybox: true 效果图展示 以上就是 hexo搭建的博客中最优雅的放大图片的方法]]></content>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你搭建自己的博客]]></title>
    <url>%2Fmy-blog%2F2019%2F04%2F18%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[使用Hexo搭建一个属于自己的博客网站并使用 Next 模版 写在前面： 其实在去年（2018）的时候就已经搭建过博客并写了几篇文章，但是由于当时太忙导致自己连博客的代码写在什么地方都忘记了。现在新开始搭建一个博客分享一些自己项目或者其他地方的一些理解。好了，开始我们第一篇文章的表演。 博客存放 原来我的博客是放在阿里云上的但是发现用处不是很大，没什么人访问最终我还是准备转移到github上。 在 github 上去new一个仓库，具体操作还请百度，或者加我QQ“一对一教学” Hexo 项目构建 全局下载 hexo-cli 下载完毕以后，请记得先去看下命令操作，以最新的文档为准，命令说明 看完命令，在命令行工具里面输入 hexo s --debug 启动我们的服务网页显示这个的时候就说明初步的工作完成 启动完成没有问题，然后我们来修改下主题，先找到根目录下的 _config.yml 文件，再找到 theme 替换成图片这样，再把 next目录下的_config.yml这个修改一下，一共四种，自己换一种喜欢的，当然你也可以选择其他主题 博客部署注意两点 需要注意的地方就是 根目录下的_config.yml 网址部分的路径配置一定要搞清楚，不然很容易导致项目中css和js加载不出来的情况 ，这里一定要注意下，具体说明请看文档 因为我项目路径是属于 https://github.com/MrMeiyu/my-blog 二级路由，所以我这里会写成 /my-blog ，如果有的小伙伴直接是一级路由的话，就写成 / 就好了 就是git部署地址一定要写对，还有如果你的分支没有构建也不需要管它，按照我的分支来就写好了。 ,具体说明请看文档 以上就是 使用Hexo搭建一个属于自己的博客网站并使用 Next 模版 ，如果还有不懂的朋友请QQ联系我]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
</search>
